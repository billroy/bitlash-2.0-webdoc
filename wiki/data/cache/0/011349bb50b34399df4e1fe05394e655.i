a:109:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:17:"Background Macros";i:1;i:2;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:104:"Bitlash can run up to 8 macros in the background while you work in the foreground at the command prompt.";}i:2;i:32;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:136;}i:6;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:136;}i:7;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:143;}i:8;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"The Run Command";i:1;i:3;i:2;i:143;}i:2;i:143;}i:9;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:143;}i:10;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:143;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:170;}i:12;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:174;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"run";}i:2;i:176;}i:14;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:179;}i:15;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:" command runs a macro in the background:";}i:2;i:181;}i:16;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:227;}i:17;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:92:"
> run toggle13	// LED on D13 starts flashing
>			// and you get the foreground prompt back
";i:1;N;i:2;N;}i:2;i:227;}i:18;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:227;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:"Think of the run X command as being a ";}i:2;i:329;}i:20;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:367;}i:21;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"while 1: X";}i:2;i:368;}i:22;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:378;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:" that runs in the time between 
your keystrokes. ";}i:2;i:379;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:428;}i:25;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:428;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:139:"In the above example, toggle13 will be called Very Frequently, perhaps as often as once each time your loop() procedure calls runBitlash().";}i:2;i:430;}i:27;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:569;}i:28;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:569;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:136:"Bitlash stops all background macros when you press ^C.  You can also stop a specific one using ps (to discover its process id) and stop.";}i:2;i:571;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:713;}i:31;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:122:"
> ps			// list running background macros
0: toggle13		// toggle13 is number 0
> stop 0		// or stop * or ^C to stop all
>
";i:1;N;i:2;N;}i:2;i:713;}i:32;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:844;}i:33;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:850;}i:34;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:66:"Run Command: Optional [,snoozems] argument and changes to snooze()";i:1;i:3;i:2;i:850;}i:2;i:850;}i:35;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:850;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:850;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:928;}i:38;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:932;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"run";}i:2;i:933;}i:40;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:936;}i:41;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:299:" command has been extended to provide control over how often each background task is run without using the snooze() command.  This is convenient for tasks that run on a fixed timer: many macros can dispense with the snoozing thing entirely if the runtime interval is known when the macro is started.";}i:2;i:937;}i:42;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1236;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1236;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"For example, this will run the macro t1 every 27 millis or so:";}i:2;i:1238;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1306;}i:46;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:11:"
run t1,27
";i:1;N;i:2;N;}i:2;i:1306;}i:47;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1306;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:158:"If the optional snoozems argument is not specified it is treated as zero: in other words, you must manage the snooze interval in your macro's code; see below.";}i:2;i:1327;}i:49;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1485;}i:50;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1485;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:177:"This change also has a small impact on semantics of the snooze() function.  Previously, snooze() would set the time-at-which-the-task-is-eligible to run immediately when called.";}i:2;i:1487;}i:52;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1664;}i:53;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1664;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:469:"The new behavior is subtly different: the scheduling takes place somewhat later, when the macro exits the current invocation, not at the time of some call to snooze().  Bitlash maintains a snoozems value for each background task; by default it is zero, and the task is called as fast as the round-robin gets back to it.  If you specify a value in the run command or by calling snooze, this value is saved and applied in the rescheduling calculation when the task exits.";}i:2;i:1666;}i:55;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2136;}i:56;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:2136;}i:57;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2142;}i:58;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:52:"Run Your Application Automatically in the Background";i:1;i:3;i:2;i:2142;}i:2;i:2142;}i:59;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2142;}i:60;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2142;}i:61;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:158:"Use the startup macro to do a run on your top-level macro and your application
can run in the background while you have control of the keyboard to poke at it:";}i:2;i:2206;}i:62;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2370;}i:63;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:79:"
>startup:="run myapp"
> boot
bitlash here! v0.6...
302 bytes free
>ps
0:myapp
";i:1;N;i:2;N;}i:2;i:2370;}i:64;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:2458;}i:65;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2464;}i:66;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:35:"Don't delay(); use snooze() instead";i:1;i:3;i:2;i:2464;}i:2;i:2464;}i:67;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2464;}i:68;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2464;}i:69;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:194:"If your objective is to present the illusion of multitasking, you should avoid
using the delay() function in macros, since everything else comes to a screeching halt while 
delay() is happening.";}i:2;i:2510;}i:70;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2704;}i:71;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2704;}i:72;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"Foreground keyboard entry may become sluggish if you have many tasks with delay()s more than a few millis each.";}i:2;i:2706;}i:73;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2817;}i:74;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2817;}i:75;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:210:"Bitlash provides the snooze(ms) function to give your background macro tasks a way to delay without hogging the CPU. Bitlash suspends a task which calls snooze() until the specified number of millis has passed.";}i:2;i:2819;}i:76;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3029;}i:77;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3029;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:213:"NOTE: Calling snooze() has no apparent immediate effect. Your macro continues to 
execute, if there is further code after the snooze(). But bitlash will not re-enter  your task until the specified time has passed.";}i:2;i:3031;}i:79;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3244;}i:80;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3244;}i:81;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"Here is an improved toggle13 that uses snooze() instead of delay():";}i:2;i:3246;}i:82;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3319;}i:83;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:54:"
> snooze13:="d13=!d13; snooze(100)"
> run snooze13
>
";i:1;N;i:2;N;}i:2;i:3319;}i:84;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3319;}i:85;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"Since snooze() means ";}i:2;i:3383;}i:86;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3404;}i:87;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:"don't call me again for a while";}i:2;i:3405;}i:88;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3436;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" instead of ";}i:2;i:3437;}i:90;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3449;}i:91;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"please spin away some time";}i:2;i:3450;}i:92;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3476;}i:93;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:", you will find that your foreground typing and responsiveness of other background macros is much improved compared with ";}i:2;i:3477;}i:94;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3598;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"run toggle13";}i:2;i:3599;}i:96;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3611;}i:97;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:3612;}i:98;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3614;}i:99;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:3614;}i:100;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3620;}i:101;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:38:"Example: Asynchronous Background Tasks";i:1;i:3;i:2;i:3620;}i:2;i:3620;}i:102;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3620;}i:103;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3620;}i:104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:150:"Here is an example of three asynchronous background tasks each doing its thing on its own little timeline, using snooze() to set its calling interval:";}i:2;i:3670;}i:105;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3826;}i:106;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:307:"
> chirp:="print \"chirp \",; snooze(2500)"
> eep:="print \"eep \",; snooze(800);"
> ribbit:="print \"ribbit \",; snooze(3500);"
> nightfall:="run eep;run chirp;run ribbit;ps"
> nightfall
0:eep
1:chirp
2:ribbit
> eep chirp ribbit eep eep eep chirp eep
ribbit eep eep chirp eep eep ribbit eepÂ 
chirp eep ^C
";i:1;N;i:2;N;}i:2;i:3826;}i:107;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4142;}i:108;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:4142;}}