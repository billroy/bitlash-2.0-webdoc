a:106:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:8:"bitty.py";i:1;i:2;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:"The python program known as ";}i:2;i:23;}i:5;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:51;}i:6;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"bitty.py";}i:2;i:53;}i:7;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:61;}i:8;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:172:" is a serial port proxy.  It runs on an Arduino-connected PC and makes the Arduino available over the network for connection via telnet, nc, or your favorite telnet client.";}i:2;i:63;}i:9;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:235;}i:10;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:235;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:86:"With Bitty you can make your Arduino available on the Internet with no extra hardware.";}i:2;i:237;}i:12;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:323;}i:13;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:323;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:171:"There are some nice features for Arduino users.  You can unplug one Arduino and plug in another and bitty will find it.  And the network port and baud rate are adjustable.";}i:2;i:325;}i:15;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:496;}i:16;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:498;}i:17;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"Requirements";i:1;i:3;i:2;i:498;}i:2;i:498;}i:18;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:498;}i:19;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:520;}i:20;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:520;}i:21;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:520;}i:22;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:524;}i:23;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:17:"http://python.org";i:1;s:6:"python";}i:2;i:525;}i:24;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" 2.4 or 2.5";}i:2;i:553;}i:25;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:564;}i:26;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:564;}i:27;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:564;}i:28;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:564;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" pySerial from ";}i:2;i:568;}i:30;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:47:"http://sourceforge.net/projects/pyserial/files/";i:1;s:11:"SourceForge";}i:2;i:583;}i:31;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:646;}i:32;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:646;}i:33;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:646;}i:34;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:649;}i:35;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:5:"Usage";i:1;i:3;i:2;i:649;}i:2;i:649;}i:36;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:649;}i:37;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:649;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:66:"To use: first, start the serial-to-net proxy and leave it running:";}i:2;i:665;}i:39;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:737;}i:40;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:29:"
$ python bitty.py [options]
";i:1;N;i:2;N;}i:2;i:737;}i:41;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:737;}i:42;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:776;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:92:"and then, in another terminal window, connect to it with your favorite telnet or nc program:";}i:2;i:779;}i:44;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:871;}i:45;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:79:"
$ nc localhost 8080
$ telnet localhost 8080
$ telnet arduino.bitlash.net 8080
";i:1;N;i:2;N;}i:2;i:878;}i:46;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:878;}i:47;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:"Plug in Arduino via the USB-to-serial cable and you should connect up automatically.";}i:2;i:967;}i:48;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1051;}i:49;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1051;}i:50;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:1053;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"Note:";}i:2;i:1055;}i:52;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:1060;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:" Type 'logout' when done for a clean disconnect.";}i:2;i:1062;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1110;}i:55;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1112;}i:56;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:7:"Options";i:1;i:3;i:2;i:1112;}i:2;i:1112;}i:57;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1112;}i:58;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1112;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"Run Bitty with the ";}i:2;i:1131;}i:60;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:1150;}i:61;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:1151;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"help";}i:2;i:1153;}i:63;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:1157;}i:64;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:33:" option to see a list of options:";}i:2;i:1158;}i:65;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1191;}i:66;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:495:"
Arduino.app/.../library/bitlash/extras bill$ python bitty.py --help
Usage: bitty.py [options]

Options:
  -h, --help            show this help message and exit
  -p PORT, --port=PORT  network connection port [8080]
  -u USBDEVICE, --usbdevice=USBDEVICE
                        name of USB serial port device for serial connection
                        [/dev/tty.usbserial*]
  -b BAUD, --baud=BAUD  baud rate for port specified by -u [57600]
  -k, --keyboard-passthru
  -d, --debug           
";i:1;N;i:2;N;}i:2;i:1198;}i:67;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1703;}i:68;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:28:"-p, --port: set network port";i:1;i:5;i:2;i:1703;}i:2;i:1703;}i:69;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:5;}i:2;i:1703;}i:70;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1703;}i:71;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:"Bitty normally listens for incoming connections on port 8080.  If you want to use a different port, specify it like this:";}i:2;i:1739;}i:72;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1866;}i:73;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:27:"
$ python bitty.py -p 1234
";i:1;N;i:2;N;}i:2;i:1866;}i:74;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1903;}i:75;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:36:"-u, --usbdevice: set usb device name";i:1;i:5;i:2;i:1903;}i:2;i:1903;}i:76;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:5;}i:2;i:1903;}i:77;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1903;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:65:"To specify a particular usb device you can identify it like this:";}i:2;i:1947;}i:79;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2018;}i:80;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:30:"
$ python bitty.py -u TTYUSB0
";i:1;N;i:2;N;}i:2;i:2018;}i:81;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2058;}i:82;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:37:"-b, --baud: set serial port baud rate";i:1;i:5;i:2;i:2058;}i:2;i:2058;}i:83;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:5;}i:2;i:2058;}i:84;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2058;}i:85;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:136:"Bitlash, by default, listens at 57600, so Bitty tries to connect at that rate.  You can use a different rate by specifying it like this:";}i:2;i:2103;}i:86;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2245;}i:87;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:29:"
$ python bitty.py -b 115200
";i:1;N;i:2;N;}i:2;i:2245;}i:88;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2284;}i:89;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"-k, --keyboard-passthru";i:1;i:5;i:2;i:2284;}i:2;i:2284;}i:90;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:5;}i:2;i:2284;}i:91;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2284;}i:92;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:229:"This enables local keyboard input from the console running Bitty (in addition to the normal input from a remote network-connected user).  You can use this option to turn Bitty into a terminal emulator.  You can also use it for a ";}i:2;i:2315;}i:93;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:2544;}i:94;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"two steering wheel";}i:2;i:2545;}i:95;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:2563;}i:96;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:" setup: the remote user can type, and so can you.";}i:2;i:2564;}i:97;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2613;}i:98;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:22:"
$ python bitty.py -k
";i:1;N;i:2;N;}i:2;i:2620;}i:99;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:2651;}i:100;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2657;}i:101;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"Source Code for bitty.py";i:1;i:3;i:2;i:2657;}i:2;i:2657;}i:102;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2657;}i:103;a:3:{i:0;s:4:"file";i:1;a:3:{i:0;s:8271:"
#! /usr/bin/python
#
#	bitty.py: serial-to-network multiplexer for Arduino
#
#	This is a serial port proxy.  It makes a usbserial port available over the network
#	for connection via telnet, nc, or your favorite telnet client.
#
#	There are some nice features for Arduino users.  You can unplug one Arduino and
#	plug in another and bitty will find it.  And the network port and baud rate are
#	adjustable.
#
#	Requires:
#		python 2.4 or 2.5
#		pyserial from http://pyserial.wiki.sourceforge.net/pySerial
#			tested with pyserial 2.4 on OS X and Fedora 4
#
#	To use: first, start the serial-to-net proxy and leave it running:
#		$ python bitty.py [options]
#
#	and then, in another terminal window, connect to it with your favorite telnet or nc program:
#		$ nc localhost 8080
#		$ telnet localhost 8080
#		$ telnet arduino.bitlash.net 8080
#
#	plug in Arduino and you should connect up automatically.
#	Type 'logout' when done for a clean disconnect.
#
#
#	LICENSE
#
#	Copyright 2010 by Bill Roy
#
#	Permission is hereby granted, free of charge, to any person
#	obtaining a copy of this software and associated documentation
#	files (the "Software"), to deal in the Software without
#	restriction, including without limitation the rights to use,
#	copy, modify, merge, publish, distribute, sublicense, and/or sell
#	copies of the Software, and to permit persons to whom the
#	Software is furnished to do so, subject to the following
#	conditions:
#	
#	The above copyright notice and this permission notice shall be
#	included in all copies or substantial portions of the Software.
#	
#	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#	OTHER DEALINGS IN THE SOFTWARE.
#
###############################################################################

__version__ = '1.0'
__copyright__ = 'Copyright 2010 by Bill Roy'

import serial, time, socket, commands, traceback, os, sys

# serial port config
usbdevice = None
baud = 57600

# network config
port = 8080

# options
kbdpassthru = False
showflow = False


# change below here at your own risk
serialport = None
netsocket = None
netclient = None
clientaddress = None

# Net pump thread, and queued interface
import Queue
netq = Queue.Queue()
serialq = Queue.Queue()


def closeSerialPort():
	global serialport
	if serialport and serialport.isOpen(): 
		print "Closing: ", serialport.portstr
		try:
			if netclient: 
				netclient.send("Closing ")
				netclient.send(serialport.portstr)
				netclient.send("\r\n");
		except: pass
		serialport.close()


def openSerialPort():
	global serialport
	closeSerialPort()


	# serial port autoconfig
	device = usbdevice					 # command line overrides auto select
	if not device:
		devicelist = commands.getoutput("ls /dev/tty.usbserial*")
		#devicelist = commands.getoutput("ls /dev/ttyUSB*")		# this works on the XO/Fedora
	
		if devicelist[0] == '/': device = devicelist
	if not device: 
		print "Waiting for device..."
		return False

	print "Connecting to", device, baud, "..."
	if netclient:
		netclient.send('Connecting to ');
		netclient.send(device);
		netclient.send('... ');

	try:
		# two stop bits helps paste-to-terminal not lose characters
		serialport = serial.Serial(device, baud, timeout=0, stopbits=serial.STOPBITS_TWO)
		print 'Opened port: ', serialport.portstr
		if netclient:
			netclient.send("connected.\r\n")
	except:
		print 'Failed to open port'
		if netclient:
			netclient.send("failed.\r\n")
		return False
	return True


# thread to read and queue serial input
# assumes opening the serial port is handled elsewhere
def serialPumpTask(usbdevice, baud):
	while True:
		if serialport and serialport.isOpen():
			try:
				data = serialport.read(1024);
				if data:
					if showflow: print "SER:",data
					serialq.put(data)
				else:
					time.sleep(0.1)
			except:
				print "Exception reading serial port"
				traceback.print_exc()
				closeSerialPort()
		else:
			time.sleep(1.0)

def kbdPumpTask(d1,d2):
	while True:
		try:
			netq.put(os.read(sys.stdin.fileno(), 1))
		except:
			print "Exception in keyboard handler"
			traceback.print_exc()

# send network data to the serial port
def handleNetworkInput(data):
	global serialport
	try:
		if serialport and serialport.isOpen(): 
			#serialport.write(data);
			for i in range(len(data)): 
				serialport.write(data[i])
				time.sleep(0.05)
	except:
		print "Exception writing serial port"
		traceback.print_exc()
		closeSerialPort()


# send serial port data to the network socket
def handleSerialInput(data):
	global netclient
	try:
		if netclient: netclient.send(data)
		if kbdpassthru: 
			sys.stdout.write(data)
			sys.stdout.flush()
	except:
		print "Exception writing network port"
		traceback.print_exc()
		closeSerialPort()


# thread to read and queue network input
def netPumpTask(port, dummy):

	global netsocket, netclient, clientaddress
	netsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	netsocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	#socket.setblocking(0)
	netsocket.bind(('', port)) 
	netsocket.listen(1) 	# allow no waiting connections

	while True: 
		try:
			print "Listening for network connection on", socket.getfqdn(), ':', port, '/', socket.gethostname()
			netclient, clientaddress = netsocket.accept()
			print "Connection from", clientaddress
			netclient.send("g'day from bitty ")
			netclient.send(__version__)
			netclient.send(" -- type 'logout' to disconnect")
			netclient.send("\r\n");

			while True:
				if not netclient: break		# client went away: go get another one
				while not openSerialPort():
					netclient.send("Waiting for device...\r\n");
					time.sleep(2);

				while serialport.isOpen():
					data = netclient.recv(10240) 
					if data: 
						if showflow: print "NET:", data
						if data[0:6].find('logout') == 0:
							if netclient: netclient.send("Disconnected.\r\n");
							netclient.close()
							netclient = None
							closeSerialPort()
							time.sleep(1.0)		# pause to allow disconnect
						else: 
							netq.put(data)
					else: time.sleep(0.1)
		except:
			print "Exception in net pump"
			traceback.print_exc()
			closeSerialPort()


def parseOptions():
	# parse command line options
	from optparse import OptionParser
	usage = "usage: %prog [options]"
	parser = OptionParser()

	parser.add_option("-p", "--port",
						dest="port", type='int',
						help="network connection port [8080]")
	
	parser.add_option("-u", "--usbdevice",
						dest="usbdevice",
						help="name of USB serial port device for serial connection [/dev/tty.usbserial*]")

	parser.add_option("-b", "--baud",
						dest="baud", type='int',
						help="baud rate for port specified by -u [57600]")

	parser.add_option("-k", "--keyboard-passthru", action="store_true", dest="kbdpassthru")

	parser.add_option("-d", "--debug", action="store_true", dest="debug")

	(options, args) = parser.parse_args()

	if options.port:
		global port
		port = options.port
		print "Listening for connections on port:", port
	
	if options.baud:
		global baud
		baud = options.baud
		print "Serial port baud rate set to:", baud
	
	if options.usbdevice:
		global usbdevice
		usbdevice = options.usbdevice
		print "Using USB serial device: ", usbdevice

	if options.debug:
		global showflow
		showflow = True

	if options.kbdpassthru:
		global kbdpassthru
		kbdpassthru = True

	#if options.password:
	#	import getpass
	#	password = getpass.getpass("Password:")


if __name__ == '__main__':

	parseOptions()

	import thread
	net_pump_thread = thread.start_new_thread(netPumpTask, (port, 0))
	serial_pump_thread = thread.start_new_thread(serialPumpTask, (usbdevice, baud))
	if kbdpassthru:
		kbd_pump_thread = thread.start_new_thread(kbdPumpTask, (0,0))

	while True:
		while not netq.empty(): 
			handleNetworkInput(netq.get())
			netq.task_done()

		while not serialq.empty():
			handleSerialInput(serialq.get())
			serialq.task_done()

		time.sleep(0.1)
";i:1;s:6:"python";i:2;s:8:"bitty.py";}i:2;i:2698;}i:104;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:10994;}i:105;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:10994;}}