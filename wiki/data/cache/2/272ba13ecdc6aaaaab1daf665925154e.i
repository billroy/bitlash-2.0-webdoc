a:133:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"Bitlash API";i:1;i:2;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:319:"Your Arduino C program can interact with Bitlash using the functions documented here.
Of course, in the tiny and open world of Arduino most everything is visible globally.  So feel free to dive in and call what you need.  The entry points documented here are intended to be reasonably well hardened for third party use.";}i:2;i:26;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:345;}i:6;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:345;}i:7;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:353;}i:8;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"initBitlash(baudrate);";i:1;i:3;i:2;i:353;}i:2;i:353;}i:9;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:353;}i:10;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:353;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:"You must call this first, normally from setup(), to initialize Bitlash and set the serial port baud rate.  ";}i:2;i:387;}i:12;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:495;}i:13;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:495;}i:14;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:501;}i:15;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"runBitlash();";i:1;i:3;i:2;i:501;}i:2;i:501;}i:16;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:501;}i:17;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:501;}i:18;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:233:"You must call runBitlash() from your loop() function to make Bitlash go.  The more frequently you call runBitlash(), the more smoothly foreground and background activity will run.  If you don't call runBitlash(), nothing will happen.";}i:2;i:526;}i:19;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:759;}i:20;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:759;}i:21;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:766;}i:22;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"Example: Simple Integration";i:1;i:4;i:2;i:766;}i:2;i:766;}i:23;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:766;}i:24;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:766;}i:25;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:"This is the minimum possible integration, and in fact it is the bones of the code that you will see at the bottom of bitlashdemo.pde:";}i:2;i:803;}i:26;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:942;}i:27;a:3:{i:0;s:4:"file";i:1;a:3:{i:0;s:104:"
void setup(void) {
	initBitlash(57600);
}

void loop(void) {
	runBitlash();
	// YourOtherCodeHere();
}
";i:1;s:3:"cpp";i:2;s:10:"simple.pde";}i:2;i:942;}i:28;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:1070;}i:29;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1077;}i:30;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"doCommand(char *command);";i:1;i:3;i:2;i:1077;}i:2;i:1077;}i:31;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1077;}i:32;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1077;}i:33;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:151:"A simple way to control Bitlash is to use the doCommand() function to execute commands from your code.  Your code can call doCommand() to make Bitlash ";}i:2;i:1114;}i:34;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:1265;}i:35;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"do stuff";}i:2;i:1266;}i:36;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:1274;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:1275;}i:38;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:1276;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:227:" anything you can type, actually, up to the buffer size limit.
Here's a dumb example that leads up to our next big case study: this code spends a lot of energy looking for the precise millisecond to beep at the top of the hour:";}i:2;i:1278;}i:40;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1511;}i:41;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:185:"
void setup(void) {
	initBitlash(57600);
}

void loop(void) {
	runBitlash();
	// beep at the top of the elapsed hour
	if (millis() % (60*60*1000) == 0) doCommand("beep(11,440,1000)")
}
";i:1;N;i:2;N;}i:2;i:1511;}i:42;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1511;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:119:"Lots of ways to do this better (read on for one example), but the takeaway point is that your C code can drive Bitlash.";}i:2;i:1705;}i:44;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1824;}i:45;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:1824;}i:46;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1831;}i:47;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"doCharacter(char c)";i:1;i:3;i:2;i:1831;}i:2;i:1831;}i:48;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1831;}i:49;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1831;}i:50;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:150:"It is also possible to drive Bitlash's internal command line editor one character at a time.  This is convenient if you have a character input device.";}i:2;i:1862;}i:51;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2012;}i:52;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2012;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:170:"Bitlash will buffer and echo each character until you send a carriage return '\r' or linefeed, whereupon it will execute the line, the same way it works from the console.";}i:2;i:2014;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2184;}i:55;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2184;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:95:"See the examples/bitlashtelnet2.pde telnet server for a sample integration using doCharacter().";}i:2;i:2186;}i:57;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2282;}i:58;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:2282;}i:59;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2289;}i:60;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:43:"Console redirection with setOutputHandler()";i:1;i:3;i:2;i:2289;}i:2;i:2289;}i:61;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2289;}i:62;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2289;}i:63;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:328:"You can arrange to capture all the output that Bitlash would normally send to the console serial port, and redirect it to suit your application.  Use the setOutputHandler() api to direct Bitlash to route its output to your character-handling function, which should be defined as taking a single byte and returning a void, as in:";}i:2;i:2344;}i:64;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2673;}i:65;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:113:"  setup() {
      ...
      setOutputHandler(&serialHandler);
  }
  
  void serialHandler(byte b) {
      ...
  }";}i:2;i:2673;}i:66;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2673;}i:67;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:77:"There are four examples in the Bitlash distribution that show how this works:";}i:2;i:2805;}i:68;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2882;}i:69;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2882;}i:70;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:"See examples/loutbitlash.pde for a silly example that optionally makes all the output uppercase (therefore loud).";}i:2;i:2884;}i:71;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2997;}i:72;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2997;}i:73;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:194:"See examples/bitlashtelnet.pde for an example implementing both input injection and output capture.  examples/bitlashtelnet2.pde is similar but uses the doCharacter() api instead of doCommand().";}i:2;i:2999;}i:74;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3193;}i:75;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3193;}i:76;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:"And of course the Bitlash web server, BitlashWebServer, uses this console redirection capability.  See examples/BitlashWebServer.pde";}i:2;i:3195;}i:77;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3328;}i:78;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:3328;}i:79;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3335;}i:80;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:49:"User Functions: addBitlashFunction() and getArg()";i:1;i:3;i:2;i:3335;}i:2;i:3335;}i:81;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3335;}i:82;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3335;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:"You can extend Bitlash at compile time by adding ";}i:2;i:3396;}i:84;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3445;}i:85;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"C User Functions";}i:2;i:3446;}i:86;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3462;}i:87;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:44:" to the built-in function library.  See the ";}i:2;i:3463;}i:88;a:3:{i:0;s:12:"internallink";i:1;a:2:{i:0;s:13:"userfunctions";i:1;s:14:"User Functions";}i:2;i:3507;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" page for details.";}i:2;i:3539;}i:90;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3558;}i:91;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:3558;}i:92;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3565;}i:93;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:37:"Manipulating Bitlash Variables from C";i:1;i:3;i:2;i:3565;}i:2;i:3565;}i:94;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3565;}i:95;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3565;}i:96;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:234:"Bitlash has 26 variables named a through z.  These are 32-bit signed integer values.  Your code can read and write these values using a few simple functions.  This allows your C code to control code running in Bitlash, and vice versa.";}i:2;i:3614;}i:97;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3848;}i:98;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3848;}i:99;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:275:"You refer to a variable using an integer index in the range [0..25] corresponding to ['a'..'z'].  For example, here is how your code could use the getVar command to read out the value of the bitlash variable 't' and put it into the signed long C variable named 'temperature':";}i:2;i:3850;}i:100;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4131;}i:101;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:67:"
void loop(void) {
	...
	long temperature = getVar('t'-'a');	
	...
";i:1;N;i:2;N;}i:2;i:4131;}i:102;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4131;}i:103;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"Here are the three ";}i:2;i:4208;}i:104;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"API";}i:2;i:4227;}i:105;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:110:" functions for Bitlash variable manipulation.  Examples of their use are shown below in the clock application.";}i:2;i:4230;}i:106;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4340;}i:107;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4342;}i:108;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:32:"assignVar(char var, long value);";i:1;i:3;i:2;i:4342;}i:2;i:4342;}i:109;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4342;}i:110;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4342;}i:111;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:"Assigns the (signed long 32-bit integer) value to the indicated Bitlash variable.";}i:2;i:4385;}i:112;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4472;}i:113;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:117:"
assignVar(0,42);		// a=42
// note this stylish notation to calculate the var index:
assignVar('i'-'a', 33);	// i=33
";i:1;N;i:2;N;}i:2;i:4472;}i:114;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:4597;}i:115;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4603;}i:116;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"long x = getVar(char var);";i:1;i:3;i:2;i:4603;}i:2;i:4603;}i:117;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4603;}i:118;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4603;}i:119;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:"Returns the value of the given Bitlash variable.";}i:2;i:4640;}i:120;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4694;}i:121;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:37:"
long temperature = getVar('t'-'a');	";i:1;N;i:2;N;}i:2;i:4694;}i:122;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:4739;}i:123;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4745;}i:124;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"incVar(var);";i:1;i:3;i:2;i:4745;}i:2;i:4745;}i:125;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4745;}i:126;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4745;}i:127;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:43:"Increments the designated Bitlash variable.";}i:2;i:4768;}i:128;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4817;}i:129;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:26:"
incVar('i'-'a');		// i++
";i:1;N;i:2;N;}i:2;i:4817;}i:130;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:4851;}i:131;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4857;}i:132;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:4857;}}