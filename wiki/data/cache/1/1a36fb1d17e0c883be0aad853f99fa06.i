a:117:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"Background Functions";i:1;i:2;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:"Bitlash can run up to 8 functions in the background while you work in the foreground at the command prompt.";}i:2;i:35;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:142;}i:6;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:142;}i:7;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:149;}i:8;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"The Run Command";i:1;i:3;i:2;i:149;}i:2;i:149;}i:9;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:149;}i:10;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:149;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:176;}i:12;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:180;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"run";}i:2;i:182;}i:14;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:185;}i:15;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:43:" command runs a function in the background:";}i:2;i:187;}i:16;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:236;}i:17;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:90:"
> run toggle13	// LED on D13 starts flashing
>	// and you get the foreground prompt back
";i:1;N;i:2;N;}i:2;i:236;}i:18;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:236;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:"Think of the run X command as being a ";}i:2;i:336;}i:20;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:374;}i:21;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"while 1 X";}i:2;i:375;}i:22;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:384;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:" that runs in the time between 
your keystrokes. ";}i:2;i:385;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:434;}i:25;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:434;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:139:"In the above example, toggle13 will be called Very Frequently, perhaps as often as once each time your loop() procedure calls runBitlash().";}i:2;i:436;}i:27;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:575;}i:28;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:575;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:139:"Bitlash stops all background functions when you press ^C.  You can also stop a specific one using ps (to discover its process id) and stop.";}i:2;i:577;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:722;}i:31;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:125:"
> ps			// list running background functions
0: toggle13		// toggle13 is number 0
> stop 0		// or stop * or ^C to stop all
>
";i:1;N;i:2;N;}i:2;i:722;}i:32;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:856;}i:33;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:862;}i:34;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:66:"Run Command: Optional [,snoozems] argument and changes to snooze()";i:1;i:3;i:2;i:862;}i:2;i:862;}i:35;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:862;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:862;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:940;}i:38;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:944;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"run";}i:2;i:945;}i:40;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:948;}i:41;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:" command has an optional ";}i:2;i:949;}i:42;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:974;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"snoozems";}i:2;i:976;}i:44;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:984;}i:45;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:253:" argument to provide control over how often each background task is run.  This is convenient for tasks that run on a fixed timer: many functions can dispense with the snoozing thing entirely if the runtime interval is known when the function is started.";}i:2;i:986;}i:46;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1239;}i:47;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1239;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:65:"For example, this will run the function t1 every 27 millis or so:";}i:2;i:1241;}i:49;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1312;}i:50;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:11:"
run t1,27
";i:1;N;i:2;N;}i:2;i:1312;}i:51;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1312;}i:52;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"If the optional ";}i:2;i:1333;}i:53;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:1349;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"snoozems";}i:2;i:1351;}i:55;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:1359;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:137:" argument is not specified it is treated as zero: in other words, you must manage the snooze interval in your function's code; see below.";}i:2;i:1361;}i:57;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1498;}i:58;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1498;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:177:"This change also has a small impact on semantics of the snooze() function.  Previously, snooze() would set the time-at-which-the-task-is-eligible to run immediately when called.";}i:2;i:1500;}i:60;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1677;}i:61;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1677;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:472:"The new behavior is subtly different: the scheduling takes place somewhat later, when the function exits the current invocation, not at the time of some call to snooze().  Bitlash maintains a snoozems value for each background task; by default it is zero, and the task is called as fast as the round-robin gets back to it.  If you specify a value in the run command or by calling snooze, this value is saved and applied in the rescheduling calculation when the task exits.";}i:2;i:1679;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2152;}i:64;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:2152;}i:65;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2158;}i:66;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:52:"Run Your Application Automatically in the Background";i:1;i:3;i:2;i:2158;}i:2;i:2158;}i:67;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2158;}i:68;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2158;}i:69;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:164:"Use the startup function to do a run on your top-level function and your application
can run in the background while you have control of the keyboard to poke at it:";}i:2;i:2222;}i:70;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2392;}i:71;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:73:"
> function startup {run myapp}
> boot
bitlash here! v2.0...
>ps
0:myapp
";i:1;N;i:2;N;}i:2;i:2392;}i:72;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:2474;}i:73;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2480;}i:74;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:35:"Don't delay(); use snooze() instead";i:1;i:3;i:2;i:2480;}i:2;i:2480;}i:75;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2480;}i:76;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2480;}i:77;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:197:"If your objective is to present the illusion of multitasking, you should avoid
using the delay() function in functions, since everything else comes to a screeching halt while 
delay() is happening.";}i:2;i:2526;}i:78;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2723;}i:79;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2723;}i:80;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"Foreground keyboard entry may become sluggish if you have many tasks with delay()s more than a few millis each.";}i:2;i:2725;}i:81;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2836;}i:82;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2836;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:213:"Bitlash provides the snooze(ms) function to give your background function tasks a way to delay without hogging the CPU. Bitlash suspends a task which calls snooze() until the specified number of millis has passed.";}i:2;i:2838;}i:84;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3051;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3051;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:215:"NOTE: Calling snooze() has no apparent immediate effect. Your function continues to execute, if there is further code after the snooze(). But bitlash will not re-enter  your task until the specified time has passed.";}i:2;i:3053;}i:87;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3268;}i:88;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3268;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"Here is an improved toggle13 that uses snooze() instead of delay():";}i:2;i:3270;}i:90;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3343;}i:91;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:63:"
> function snooze13 {d13=!d13; snooze(100);}
> run snooze13
>
";i:1;N;i:2;N;}i:2;i:3343;}i:92;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3343;}i:93;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"Since snooze() means ";}i:2;i:3416;}i:94;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3437;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:"don't call me again for a while";}i:2;i:3438;}i:96;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3469;}i:97;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" instead of ";}i:2;i:3470;}i:98;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3482;}i:99;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"please spin away some time";}i:2;i:3483;}i:100;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3509;}i:101;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:", you will find that your foreground typing and responsiveness of other background functions is much improved compared with ";}i:2;i:3510;}i:102;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3634;}i:103;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"run toggle13";}i:2;i:3635;}i:104;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3647;}i:105;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:3648;}i:106;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3650;}i:107;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:3650;}i:108;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3656;}i:109;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:38:"Example: Asynchronous Background Tasks";i:1;i:3;i:2;i:3656;}i:2;i:3656;}i:110;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3656;}i:111;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3656;}i:112;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:150:"Here is an example of three asynchronous background tasks each doing its thing on its own little timeline, using snooze() to set its calling interval:";}i:2;i:3706;}i:113;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3862;}i:114;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:334:"
> function chirp {print "chirp ",; snooze(2500);}
> function eep {print "eep ",; snooze(800);}
> function ribbit {print "ribbit ",; snooze(3500);}
> function nightfall {run eep;run chirp;run ribbit;ps}
> nightfall
0:eep
1:chirp
2:ribbit
> eep chirp ribbit eep eep eep chirp eep
ribbit eep eep chirp eep eep ribbit eep 
chirp eep ^C
";i:1;N;i:2;N;}i:2;i:3862;}i:115;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4205;}i:116;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:4205;}}